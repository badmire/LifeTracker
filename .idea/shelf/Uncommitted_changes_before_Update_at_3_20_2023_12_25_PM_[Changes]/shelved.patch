Index: app/src/main/java/com/example/lifetracker/ui/OverviewFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.lifetracker.ui\r\n\r\nimport android.os.Bundle\r\nimport android.util.Log\r\nimport android.view.View\r\nimport android.widget.TextView\r\nimport androidx.fragment.app.Fragment\r\nimport androidx.fragment.app.viewModels\r\nimport androidx.recyclerview.widget.LinearLayoutManager\r\nimport androidx.recyclerview.widget.RecyclerView\r\nimport com.example.lifetracker.data.TaskTemplate\r\nimport com.example.myapplication.R\r\nimport com.google.android.material.progressindicator.CircularProgressIndicator\r\n\r\nclass OverviewFragment : Fragment(R.layout.overview_fragment) {\r\n    private val TAG = \"OverviewFragment\"\r\n\r\n    private val viewModel: TaskViewModel by viewModels()\r\n    private val taskAdapter: TaskAdapter(::onTaskItemClick)\r\n\r\n    private lateinit var taskListRV: RecyclerView\r\n    private lateinit var loadingErrorTV: TextView\r\n    private lateinit var loadingIndicator: CircularProgressIndicator\r\n\r\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\r\n        super.onViewCreated(view, savedInstanceState)\r\n\r\n        loadingErrorTV = view.findViewById(R.id.tv_loading_error)\r\n        loadingIndicator = view.findViewById(R.id.loading_indicator)\r\n\r\n        /*\r\n         * Set up RecyclerView.\r\n         */\r\n        taskListRV = view.findViewById(R.id.rv_task_list)\r\n        taskListRV.layoutManager = LinearLayoutManager(requireContext())\r\n        taskListRV.setHasFixedSize(true)\r\n        taskListRV.adapter = taskAdapter\r\n\r\n        /*\r\n         * Set up an observer on the current task data.  If the taskTemplates list is not null, display\r\n         * it in the UI.\r\n         */\r\n        viewModel.taskTemplates.observe(viewLifecycleOwner) { taskTemplates ->\r\n            if (taskTemplates != null) {\r\n                taskAdapter.updateTaskTemplates(taskTemplates)\r\n                taskListRV.visibility = View.VISIBLE\r\n                taskListRV.scrollToPosition(0)\r\n                // supportActionBar?.title = forecast.city.name\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Set up an observer on the most recent task records.  If any member of the taskRecords\r\n         * list is not null, display it in the UI.\r\n         */\r\n        viewModel.taskRecords.observe(viewLifecycleOwner) { taskRecords ->\r\n            if (taskRecords != null) {\r\n                taskAdapter.updateTaskRecords(taskRecords)\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Set up an observer on the error associated with the current API call.  If the error is\r\n         * not null, display the error that occurred in the UI.\r\n         */\r\n        viewModel.error.observe(viewLifecycleOwner) { error ->\r\n            if (error != null) {\r\n                loadingErrorTV.text = getString(R.string.loading_error, error.message)\r\n                loadingErrorTV.visibility = View.VISIBLE\r\n                Log.e(TAG, \"Error fetching forecast: ${error.message}\")\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Set up an observer on the loading status of the API query.  Display the correct UI\r\n         * elements based on the current loading status.\r\n         */\r\n        viewModel.loading.observe(viewLifecycleOwner) { loading ->\r\n            if (loading) {\r\n                loadingIndicator.visibility = View.VISIBLE\r\n                loadingErrorTV.visibility = View.INVISIBLE\r\n                taskListRV.visibility = View.INVISIBLE\r\n            } else {\r\n                loadingIndicator.visibility = View.INVISIBLE\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun onResume() {\r\n        super.onResume()\r\n\r\n        /*\r\n         * Here, we're reading the current preference values and triggering a data fetching\r\n         * operation in onResume().  This avoids the need to set up a preference change listener.\r\n         * It also means that a new API call could potentially be made every time the activity\r\n         * is resumed.  However, because of the basic caching that's implemented in the\r\n         * `FiveDayForecastRepository` class, an API call will actually only be made whenever\r\n         * the city or units setting changes (which is exactly what we want).\r\n         */\r\n        // TODO: Settings stuff goes here\r\n        // val sharedPrefs = PreferenceManager.getDefaultSharedPreferences(requireContext())\r\n        // val city = sharedPrefs.getString(getString(R.string.pref_city_key), \"Corvallis,OR,US\")\r\n        // val units = sharedPrefs.getString(getString(R.string.pref_units_key), null)\r\n        viewModel.loadTasks()\r\n    }\r\n\r\n    /**\r\n     * This method is passed into the RecyclerView adapter to handle clicks on individual items\r\n     * in the list of forecast items.  When a forecast item is clicked, a new activity is launched\r\n     * to view its details.\r\n     */\r\n    private fun onTaskItemClick(taskTemplate: TaskTemplate) {\r\n        Log.d(TAG, \"onTaskItemClick() called, task: $taskTemplate\")\r\n        // TODO: Handle navigation\r\n        //val directions = OverviewFragmentDirections.navigateToForecastDetail(forecastPeriod, forecastCity = forecastAdapter.forecastCity!!)\r\n        //findNavController().navigate(directions)\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/lifetracker/ui/OverviewFragment.kt b/app/src/main/java/com/example/lifetracker/ui/OverviewFragment.kt
--- a/app/src/main/java/com/example/lifetracker/ui/OverviewFragment.kt	(revision 11c8691b149409e237092c783d4bed0274c31e8a)
+++ b/app/src/main/java/com/example/lifetracker/ui/OverviewFragment.kt	(date 1679329690508)
@@ -13,56 +13,51 @@
 import com.google.android.material.progressindicator.CircularProgressIndicator
 
 class OverviewFragment : Fragment(R.layout.overview_fragment) {
+    // Magic from Hess
     private val TAG = "OverviewFragment"
 
+    // Instatiate viewModel and adapter
     private val viewModel: TaskViewModel by viewModels()
     private val taskAdapter: TaskAdapter(::onTaskItemClick)
 
+    // Instantiate reference for views from the layout
     private lateinit var taskListRV: RecyclerView
     private lateinit var loadingErrorTV: TextView
     private lateinit var loadingIndicator: CircularProgressIndicator
 
+    // Initialization code
     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        // Required magic
         super.onViewCreated(view, savedInstanceState)
 
+        // Fetch views for the loading indicator and error message
         loadingErrorTV = view.findViewById(R.id.tv_loading_error)
         loadingIndicator = view.findViewById(R.id.loading_indicator)
 
-        /*
-         * Set up RecyclerView.
-         */
+        // Fetch and configure task recycler view
         taskListRV = view.findViewById(R.id.rv_task_list)
         taskListRV.layoutManager = LinearLayoutManager(requireContext())
         taskListRV.setHasFixedSize(true)
         taskListRV.adapter = taskAdapter
 
-        /*
-         * Set up an observer on the current task data.  If the taskTemplates list is not null, display
-         * it in the UI.
-         */
+        // Set observer for task list in viewModel
         viewModel.taskTemplates.observe(viewLifecycleOwner) { taskTemplates ->
-            if (taskTemplates != null) {
-                taskAdapter.updateTaskTemplates(taskTemplates)
-                taskListRV.visibility = View.VISIBLE
-                taskListRV.scrollToPosition(0)
-                // supportActionBar?.title = forecast.city.name
+            if (taskTemplates != null) { // Check for empty list
+                taskAdapter.updateTaskTemplates(taskTemplates) // Update UI with new data
+                taskListRV.visibility = View.VISIBLE // Ensure RV is visible after loading/error shennanigans
+                taskListRV.scrollToPosition(0) // Scroll back to the top
             }
         }
 
-        /*
-         * Set up an observer on the most recent task records.  If any member of the taskRecords
-         * list is not null, display it in the UI.
-         */
+        // Set observer for records list in viewModel
+        // Needed to set the "last done" stamp
         viewModel.taskRecords.observe(viewLifecycleOwner) { taskRecords ->
             if (taskRecords != null) {
                 taskAdapter.updateTaskRecords(taskRecords)
             }
         }
 
-        /*
-         * Set up an observer on the error associated with the current API call.  If the error is
-         * not null, display the error that occurred in the UI.
-         */
+        // Set observer for API error
         viewModel.error.observe(viewLifecycleOwner) { error ->
             if (error != null) {
                 loadingErrorTV.text = getString(R.string.loading_error, error.message)
@@ -88,27 +83,17 @@
 
     override fun onResume() {
         super.onResume()
-
-        /*
-         * Here, we're reading the current preference values and triggering a data fetching
-         * operation in onResume().  This avoids the need to set up a preference change listener.
-         * It also means that a new API call could potentially be made every time the activity
-         * is resumed.  However, because of the basic caching that's implemented in the
-         * `FiveDayForecastRepository` class, an API call will actually only be made whenever
-         * the city or units setting changes (which is exactly what we want).
-         */
         // TODO: Settings stuff goes here
         // val sharedPrefs = PreferenceManager.getDefaultSharedPreferences(requireContext())
         // val city = sharedPrefs.getString(getString(R.string.pref_city_key), "Corvallis,OR,US")
         // val units = sharedPrefs.getString(getString(R.string.pref_units_key), null)
+
+        // This is the actual call that kicks off all of the database operations and updating the UI
         viewModel.loadTasks()
     }
 
-    /**
-     * This method is passed into the RecyclerView adapter to handle clicks on individual items
-     * in the list of forecast items.  When a forecast item is clicked, a new activity is launched
-     * to view its details.
-     */
+    // Onclick function for each of the RecyclerView cards
+    // Navigates into the task detail view for the selected task.
     private fun onTaskItemClick(taskTemplate: TaskTemplate) {
         Log.d(TAG, "onTaskItemClick() called, task: $taskTemplate")
         // TODO: Handle navigation
Index: app/src/main/java/com/example/lifetracker/data/TaskRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.lifetracker.data\r\n\r\nimport com.example.lifetracker.api.GoogleDriveService\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\n\r\n// The primary function of this class is to be the generic entrypoint into the DB\r\n// Also handles all of the coroutines/async operations\r\nclass TaskRepository(\r\n    //private val service: GoogleDriveService,\r\n    //private val ioDispatcher: CoroutineDispatcher,\r\n    private val taskDao: TaskTemplateDao,\r\n    private val recordDao: TaskRecordDao\r\n) {\r\n    // Insertion Functions\r\n    suspend fun insertNewTask(template: TaskTemplate) = taskDao.insert(template)\r\n    suspend fun insertNewRecord(record: TaskRecord) = recordDao.insert(record)\r\n\r\n    // Deletion Functions\r\n    suspend fun deleteTask(template: TaskTemplate) = taskDao.delete(template)\r\n    suspend fun deleteTask(record: TaskRecord) = recordDao.delete(record)\r\n\r\n    // Fetcher Functions\r\n    fun getAllTaskTemplates() = taskDao.getAllTasks()\r\n    fun getAllRecords() = recordDao.getAllTasks()\r\n\r\n    fun getTaskTemplateByName(name: String?) = taskDao.getTaskByName(name)\r\n    fun getSpecificRecord(stamp: Int, template: String) = recordDao.getSpecificRecord(stamp,template)\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/lifetracker/data/TaskRepository.kt b/app/src/main/java/com/example/lifetracker/data/TaskRepository.kt
--- a/app/src/main/java/com/example/lifetracker/data/TaskRepository.kt	(revision 11c8691b149409e237092c783d4bed0274c31e8a)
+++ b/app/src/main/java/com/example/lifetracker/data/TaskRepository.kt	(date 1679340217640)
@@ -21,8 +21,10 @@
 
     // Fetcher Functions
     fun getAllTaskTemplates() = taskDao.getAllTasks()
-    fun getAllRecords() = recordDao.getAllTasks()
+    fun getAllRecords(name: String) = recordDao.getAllRecords(name)
 
     fun getTaskTemplateByName(name: String?) = taskDao.getTaskByName(name)
     fun getSpecificRecord(stamp: Int, template: String) = recordDao.getSpecificRecord(stamp,template)
+
+    fun getLatestRecord(template_name: String) = recordDao.getLatestRecord(template_name)
 }
\ No newline at end of file
Index: app/src/main/java/com/example/lifetracker/data/Task.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/lifetracker/data/Task.kt b/app/src/main/java/com/example/lifetracker/data/Task.kt
new file mode 100644
--- /dev/null	(date 1679327419079)
+++ b/app/src/main/java/com/example/lifetracker/data/Task.kt	(date 1679327419079)
@@ -0,0 +1,8 @@
+package com.example.lifetracker.data
+
+
+// Packages up TaskTemplate and Records for easy transit around the application
+data class Task(
+    val template: TaskTemplate,
+    val records: List<TaskRecord>
+)
\ No newline at end of file
